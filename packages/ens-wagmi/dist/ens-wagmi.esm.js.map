{"version":3,"file":"ens-wagmi.esm.js","sources":["../src/utils/utils.ts","../src/utils/specs/erc1155.ts","../src/utils/specs/erc721.ts","../src/utils/specs/uri.ts","../src/utils/parseAvatarString.ts","../src/useEnsContractRead.tsx","../src/useEnsContractWrite.tsx","../src/useResolverContract.tsx","../src/useResolverContractRead.tsx","../src/useResolverContractWrite.tsx","../src/usePublicResolverContract.tsx","../src/usePublicResolverRead.tsx","../src/usePublicResolverWrite.tsx","../src/useReverseRegistrarContractRead.tsx","../src/useReverseRegistrarContractWrite.tsx"],"sourcesContent":["import axios, { Axios } from 'axios';\nimport { Buffer } from 'buffer/';\nimport * as multiformats from 'multiformats';\nimport createDOMPurify from 'dompurify';\nimport isSVG from 'is-svg';\nimport { urlJoin } from 'url-join-ts';\n\nconst IPFS_SUBPATH = '/ipfs/';\nconst IPNS_SUBPATH = '/ipns/';\nconst ipfsRegex =\n  /(?<protocol>ipfs:\\/|ipns:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/;\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*)?(,)/;\n\nexport function isCID(hash: any) {\n  // check if given string or object is a valid IPFS CID\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(multiformats.CID.parse(hash));\n    }\n\n    return Boolean(multiformats.CID.asCID(hash));\n  } catch (_error) {\n    return false;\n  }\n}\n\n// simple assert without nested check\nexport function assert(condition: any, message: string) {\n  if (!condition) {\n    throw message;\n  }\n}\nexport interface BaseError {}\nexport class BaseError extends Error {\n  __proto__: Error;\n  constructor(message?: string) {\n    const trueProto = new.target.prototype;\n    super(message);\n\n    this.__proto__ = trueProto;\n  }\n}\nexport class NFTURIParsingError extends BaseError {}\nexport function parseNFT(uri: string, seperator: string = '/') {\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  try {\n    assert(uri, 'parameter URI cannot be empty');\n\n    if (uri.startsWith('did:nft:')) {\n      // convert DID to CAIP\n      uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n    }\n\n    const [reference, asset_namespace, tokenID] = uri.split(seperator);\n    const [eip_namespace, chainID] = reference.split(':');\n    const [erc_namespace, contractAddress] = asset_namespace.split(':');\n\n    assert(\n      eip_namespace && eip_namespace.toLowerCase() === 'eip155',\n      'Only EIP-155 is supported'\n    );\n    assert(chainID, 'chainID not found');\n    assert(contractAddress, 'contractAddress not found');\n    assert(erc_namespace, 'erc namespace not found');\n    assert(tokenID, 'tokenID not found');\n\n    return {\n      chainID: Number(chainID),\n      namespace: erc_namespace.toLowerCase(),\n      contractAddress,\n      tokenID,\n    };\n  } catch (error) {\n    throw new NFTURIParsingError(`${error as string} - ${uri}`);\n  }\n}\n\nexport function resolveURI(\n  uri: string,\n  customGateway?: string\n): { uri: string; isOnChain: boolean; isEncoded: boolean } {\n  // resolves uri based on its' protocol\n  const isEncoded = base64Regex.test(uri);\n  if (isEncoded || uri.startsWith('http')) {\n    return { uri, isOnChain: isEncoded, isEncoded };\n  }\n\n  const ipfsGateway = customGateway || 'https://ipfs.io';\n  const ipfsRegexpResult = uri.match(ipfsRegex);\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = ipfsRegexpResult?.groups || {};\n  if ((protocol === 'ipns:/' || subpath === 'ipns/') && target) {\n    return {\n      uri: urlJoin(ipfsGateway, IPNS_SUBPATH, target, subtarget),\n      isOnChain: false,\n      isEncoded: false,\n    };\n  } else if (isCID(target)) {\n    // Assume that it's a regular IPFS CID and not an IPNS key\n    return {\n      uri: urlJoin(ipfsGateway, IPFS_SUBPATH, target, subtarget),\n      isOnChain: false,\n      isEncoded: false,\n    };\n  } else {\n    // we may want to throw error here\n    return {\n      uri: uri.replace(dataURIRegex, ''),\n      isOnChain: true,\n      isEncoded: false,\n    };\n  }\n}\n\nfunction _sanitize(data: string, jsDomWindow?: any): Buffer {\n  let domWindow;\n  try {\n    domWindow = window;\n  } catch {\n    // if js process run under nodejs require jsdom window\n    if (!jsDomWindow) {\n      throw Error('In node environment JSDOM window is required');\n    }\n    domWindow = jsDomWindow;\n  }\n  const DOMPurify = createDOMPurify(domWindow as any);\n  // purges malicious scripting from svg content\n  const cleanDOM = DOMPurify.sanitize(data);\n  return Buffer.from(cleanDOM);\n}\n\nexport interface ImageURIOpts {\n  metadata: any;\n  customGateway?: string;\n  jsdomWindow?: any;\n}\n\nexport function getImageURI({\n  metadata,\n  customGateway,\n  jsdomWindow,\n}: ImageURIOpts) {\n  // retrieves image uri from metadata, if image is onchain then convert to base64\n  const { image, image_url, image_data } = metadata;\n\n  const _image = image || image_url || image_data;\n  assert(_image, 'Image is not available');\n  const { uri: parsedURI } = resolveURI(_image || '', customGateway);\n\n  if (parsedURI.startsWith('data:') || parsedURI.startsWith('http')) {\n    return parsedURI;\n  }\n\n  if (isSVG(parsedURI)) {\n    // svg - image_data\n    const data = _sanitize(parsedURI, jsdomWindow);\n    return `data:image/svg+xml;base64,${data.toString('base64')}`;\n  }\n  return null;\n}\n\nexport function createCacheAdapter(fetch: Axios, ttl: number) {\n  // creates cache adapter for axios\n  const { setupCache } = require('axios-cache-interceptor');\n  setupCache(fetch, {\n    ttl: ttl * 1000,\n  });\n}\n\nfunction createFetcher({ ttl }: { ttl?: number }) {\n  const _fetch = axios.create();\n  if (ttl && ttl > 0) {\n    createCacheAdapter(_fetch, ttl);\n  }\n  return _fetch;\n}\n\nexport const fetch = createFetcher({});\n","import { BaseProvider } from '@ethersproject/providers';\nimport { Contract } from '@ethersproject/contracts';\nimport { Buffer } from 'buffer/';\nimport { fetch, resolveURI } from '../utils';\n\nconst abi = [\n  'function uri(uint256 _id) public view returns (string memory)',\n  'function balanceOf(address account, uint256 id) public view returns (uint256)',\n];\n\nexport default class ERC1155 {\n  async getMetadata(\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) {\n    // exclude opensea api which does not follow erc1155 spec\n    const tokenIDHex = !tokenID.startsWith('https://api.opensea.io')\n      ? tokenID.replace('0x', '').padStart(64, '0')\n      : tokenID;\n    const contract = new Contract(contractAddress, abi, provider);\n    const [tokenURI, balance] = await Promise.all([\n      contract.uri(tokenID),\n      ownerAddress && contract.balanceOf(ownerAddress, tokenID),\n    ]);\n    // if user has valid address and if token balance of given address is greater than 0\n    const isOwner = !!(ownerAddress && balance.gt(0));\n\n    const { uri: resolvedURI, isOnChain, isEncoded } = resolveURI(tokenURI);\n    let _resolvedUri = resolvedURI;\n    if (isOnChain) {\n      if (isEncoded) {\n        _resolvedUri = Buffer.from(\n          resolvedURI.replace('data:application/json;base64,', ''),\n          'base64'\n        ).toString();\n      }\n      return JSON.parse(_resolvedUri);\n    }\n    const response = await fetch(\n      resolvedURI.replace(/(?:0x)?{id}/, tokenIDHex)\n    );\n    const metadata = await response?.data;\n    return { ...metadata, is_owner: isOwner };\n  }\n}\n","import { BaseProvider } from '@ethersproject/providers';\nimport { Contract } from '@ethersproject/contracts';\nimport { Buffer } from 'buffer/';\nimport { fetch, resolveURI } from '../utils';\n\nconst abi = [\n  'function tokenURI(uint256 tokenId) external view returns (string memory)',\n  'function ownerOf(uint256 tokenId) public view returns (address)',\n];\n\nexport default class ERC721 {\n  async getMetadata(\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) {\n    const contract = new Contract(contractAddress, abi, provider);\n    const [tokenURI, owner] = await Promise.all([\n      contract.tokenURI(tokenID),\n      ownerAddress && contract.ownerOf(tokenID),\n    ]);\n    // if user has valid address and if owner of the nft matches with the owner address\n    const isOwner = !!(\n      ownerAddress && owner.toLowerCase() === ownerAddress.toLowerCase()\n    );\n\n    const { uri: resolvedURI, isOnChain, isEncoded } = resolveURI(tokenURI);\n    let _resolvedUri = resolvedURI;\n    if (isOnChain) {\n      if (isEncoded) {\n        _resolvedUri = Buffer.from(\n          resolvedURI.replace('data:application/json;base64,', ''),\n          'base64'\n        ).toString();\n      }\n      return JSON.parse(_resolvedUri);\n    }\n    const response = await fetch(resolvedURI.replace(/(?:0x)?{id}/, tokenID));\n    const metadata = await response?.data;\n    return { ...metadata, is_owner: isOwner };\n  }\n}\n","import { fetch, resolveURI } from '../utils';\n\nexport default class URI {\n  async getMetadata(uri: string) {\n    const { uri: resolvedURI, isOnChain } = resolveURI(uri);\n    if (isOnChain) {\n      return { image: resolvedURI };\n    }\n\n    // check if resolvedURI is an image, if it is return the url\n    const isImage = await isImageURI(resolvedURI);\n    if (isImage) {\n      return { image: resolvedURI };\n    }\n\n    // if resolvedURI is not an image, try retrieve the data.\n    const response = await fetch(resolvedURI);\n    return { image: response?.data };\n  }\n}\n\nfunction isImageURI(url: string) {\n  return new Promise((resolve) => {\n    fetch({ url, method: 'HEAD' })\n      .then((result) => {\n        if (result.status === 200) {\n          // retrieve content type header to check if content is image\n          const contentType = result.headers['content-type'];\n          resolve(contentType?.startsWith('image/'));\n        } else {\n          resolve(false);\n        }\n      })\n      .catch((error) => {\n        // if error is not cors related then fail\n        if (typeof error.response !== 'undefined') {\n          // in case of cors, use image api to validate if given url is an actual image\n          resolve(false);\n          return;\n        }\n        if (!globalThis.hasOwnProperty('Image')) {\n          // fail in NodeJS, since the error is not cors but any other network issue\n          resolve(false);\n          return;\n        }\n        const img = new Image();\n        img.onload = () => {\n          resolve(true);\n        };\n        img.onerror = () => {\n          resolve(false);\n        };\n        img.src = url;\n      });\n  });\n}\n","import { BaseProvider } from '@ethersproject/providers';\nimport ERC1155 from './specs/erc1155';\nimport ERC721 from './specs/erc721';\nimport { utils } from '@ensdomains/ens-avatar';\nimport URI from './specs/uri';\n\nexport async function handleSettled(promises: Promise<any>[]) {\n  const values = [];\n  const results = await Promise.allSettled(promises);\n  for (let result of results) {\n    if (result.status === 'fulfilled') values.push(result.value);\n    else if (result.status === 'rejected') values.push(null);\n  }\n  return values;\n}\n\nexport interface Spec {\n  getMetadata: (\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) => Promise<any>;\n}\n\nexport const specs: { [key: string]: new () => Spec } = Object.freeze({\n  erc721: ERC721,\n  erc1155: ERC1155,\n});\n\nexport async function parseAvatarString(\n  walletAddress: string,\n  avatarURI: string,\n  provider: BaseProvider\n) {\n  // test case-insensitive in case of uppercase records\n  if (!/eip155:/i.test(avatarURI)) {\n    const uriSpec = new URI();\n    const metadata = await uriSpec.getMetadata(avatarURI);\n    return utils.getImageURI({ metadata });\n  }\n\n  // parse retrieved avatar uri\n  const { chainID, namespace, contractAddress, tokenID } =\n    utils.parseNFT(avatarURI);\n\n  // detect avatar spec by namespace\n  const Spec = specs[namespace];\n  if (!Spec) throw new Error(`Unsupported namespace: ${namespace}`);\n  const spec = new Spec();\n\n  // add meta information of the avatar record\n  const host_meta = {\n    chain_id: chainID,\n    namespace,\n    contract_address: contractAddress,\n    token_id: tokenID,\n    reference_url: `https://opensea.io/assets/${contractAddress}/${tokenID}`,\n  };\n\n  const metadata = await spec.getMetadata(\n    provider,\n    walletAddress,\n    contractAddress,\n    tokenID\n  );\n  const meta_ = { host_meta, ...metadata };\n  return utils.getImageURI({ metadata: meta_ });\n}\n","import { useContractRead } from 'wagmi';\nimport ENS from '@ensdomains/ens-contracts/artifacts/contracts/registry/ENS.sol/ENS.json';\n\nexport function useEnsContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: ENS.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useEnsContractRead;\n","import { useContractWrite } from 'wagmi';\nimport ENS from '@ensdomains/ens-contracts/artifacts/contracts/registry/ENS.sol/ENS.json';\n\nexport function useEnsContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: ENS.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useEnsContractWrite;\n","import { useContract } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContract(address: string): any {\n  return useContract({\n    addressOrName: address,\n    contractInterface: Resolver.abi,\n  });\n}\n\nexport default useResolverContract;\n","import { useContractRead } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: Resolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useResolverContractRead;\n","import { useContractWrite } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: Resolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useResolverContractWrite;\n","import { useContract } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverContract(address: string): any {\n  return useContract({\n    addressOrName: address,\n    contractInterface: PublicResolver.abi,\n  });\n}\n\nexport default usePublicResolverContract;\n","import { useContractRead } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: PublicResolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default usePublicResolverRead;\n","import { useContractWrite } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: PublicResolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default usePublicResolverWrite;\n","import { useContractRead } from 'wagmi';\nimport ReverseRegistrar from '@ensdomains/ens-contracts/artifacts/contracts/registry/ReverseRegistrar.sol/ReverseRegistrar.json';\n\nexport function useReverseRegistrarContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: ReverseRegistrar.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useReverseRegistrarContractRead;\n","import { useContractWrite } from 'wagmi';\nimport ReverseRegistrar from '@ensdomains/ens-contracts/artifacts/contracts/registry/ReverseRegistrar.sol/ReverseRegistrar.json';\n\nexport function useReverseRegistrarContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: ReverseRegistrar.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useReverseRegistrarContractWrite;\n"],"names":["IPFS_SUBPATH","IPNS_SUBPATH","ipfsRegex","base64Regex","dataURIRegex","isCID","hash","Boolean","multiformats","parse","asCID","_error","resolveURI","uri","customGateway","isEncoded","test","startsWith","isOnChain","ipfsGateway","ipfsRegexpResult","match","groups","protocol","subpath","target","subtarget","urlJoin","replace","createCacheAdapter","fetch","ttl","require","setupCache","createFetcher","_fetch","axios","create","abi","ERC1155","getMetadata","provider","ownerAddress","contractAddress","tokenID","tokenIDHex","padStart","contract","Contract","Promise","all","balanceOf","tokenURI","balance","isOwner","gt","resolvedURI","_resolvedUri","Buffer","from","toString","JSON","response","data","metadata","is_owner","ERC721","ownerOf","owner","toLowerCase","URI","image","isImageURI","isImage","url","resolve","method","then","result","status","contentType","headers","error","globalThis","hasOwnProperty","img","Image","onload","onerror","src","specs","Object","freeze","erc721","erc1155","parseAvatarString","walletAddress","avatarURI","uriSpec","utils","getImageURI","parseNFT","chainID","namespace","Spec","Error","spec","host_meta","chain_id","contract_address","token_id","reference_url","meta_","useEnsContractRead","address","args","useContractRead","addressOrName","contractInterface","ENS","useEnsContractWrite","useContractWrite","useResolverContract","useContract","Resolver","useResolverContractRead","useResolverContractWrite","usePublicResolverContract","PublicResolver","usePublicResolverRead","usePublicResolverWrite","useReverseRegistrarContractRead","ReverseRegistrar","useReverseRegistrarContractWrite"],"mappings":"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"}