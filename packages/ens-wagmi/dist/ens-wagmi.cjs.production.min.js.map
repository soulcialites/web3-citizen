{"version":3,"file":"ens-wagmi.cjs.production.min.js","sources":["../src/utils/utils.ts","../src/utils/specs/erc1155.ts","../src/utils/specs/erc721.ts","../src/utils/specs/uri.ts","../src/utils/parseAvatarString.ts","../src/useEnsContractRead.tsx","../src/useEnsContractWrite.tsx","../src/usePublicResolverContract.tsx","../src/usePublicResolverRead.tsx","../src/usePublicResolverWrite.tsx","../src/useResolverContract.tsx","../src/useResolverContractRead.tsx","../src/useResolverContractWrite.tsx","../src/useReverseRegistrarContractRead.tsx","../src/useReverseRegistrarContractWrite.tsx"],"sourcesContent":["import axios, { Axios } from 'axios';\nimport { Buffer } from 'buffer/';\nimport * as multiformats from 'multiformats';\nimport createDOMPurify from 'dompurify';\nimport isSVG from 'is-svg';\nimport { urlJoin } from 'url-join-ts';\n\nconst IPFS_SUBPATH = '/ipfs/';\nconst IPNS_SUBPATH = '/ipns/';\nconst ipfsRegex =\n  /(?<protocol>ipfs:\\/|ipns:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/;\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*)?(,)/;\n\nexport function isCID(hash: any) {\n  // check if given string or object is a valid IPFS CID\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(multiformats.CID.parse(hash));\n    }\n\n    return Boolean(multiformats.CID.asCID(hash));\n  } catch (_error) {\n    return false;\n  }\n}\n\n// simple assert without nested check\nexport function assert(condition: any, message: string) {\n  if (!condition) {\n    throw message;\n  }\n}\nexport interface BaseError {}\nexport class BaseError extends Error {\n  __proto__: Error;\n  constructor(message?: string) {\n    const trueProto = new.target.prototype;\n    super(message);\n\n    this.__proto__ = trueProto;\n  }\n}\nexport class NFTURIParsingError extends BaseError {}\nexport function parseNFT(uri: string, seperator: string = '/') {\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  try {\n    assert(uri, 'parameter URI cannot be empty');\n\n    if (uri.startsWith('did:nft:')) {\n      // convert DID to CAIP\n      uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n    }\n\n    const [reference, asset_namespace, tokenID] = uri.split(seperator);\n    const [eip_namespace, chainID] = reference.split(':');\n    const [erc_namespace, contractAddress] = asset_namespace.split(':');\n\n    assert(\n      eip_namespace && eip_namespace.toLowerCase() === 'eip155',\n      'Only EIP-155 is supported'\n    );\n    assert(chainID, 'chainID not found');\n    assert(contractAddress, 'contractAddress not found');\n    assert(erc_namespace, 'erc namespace not found');\n    assert(tokenID, 'tokenID not found');\n\n    return {\n      chainID: Number(chainID),\n      namespace: erc_namespace.toLowerCase(),\n      contractAddress,\n      tokenID,\n    };\n  } catch (error) {\n    throw new NFTURIParsingError(`${error as string} - ${uri}`);\n  }\n}\n\nexport function resolveURI(\n  uri: string,\n  customGateway?: string\n): { uri: string; isOnChain: boolean; isEncoded: boolean } {\n  // resolves uri based on its' protocol\n  const isEncoded = base64Regex.test(uri);\n  if (isEncoded || uri.startsWith('http')) {\n    return { uri, isOnChain: isEncoded, isEncoded };\n  }\n\n  const ipfsGateway = customGateway || 'https://ipfs.io';\n  const ipfsRegexpResult = uri.match(ipfsRegex);\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = ipfsRegexpResult?.groups || {};\n  if ((protocol === 'ipns:/' || subpath === 'ipns/') && target) {\n    return {\n      uri: urlJoin(ipfsGateway, IPNS_SUBPATH, target, subtarget),\n      isOnChain: false,\n      isEncoded: false,\n    };\n  } else if (isCID(target)) {\n    // Assume that it's a regular IPFS CID and not an IPNS key\n    return {\n      uri: urlJoin(ipfsGateway, IPFS_SUBPATH, target, subtarget),\n      isOnChain: false,\n      isEncoded: false,\n    };\n  } else {\n    // we may want to throw error here\n    return {\n      uri: uri.replace(dataURIRegex, ''),\n      isOnChain: true,\n      isEncoded: false,\n    };\n  }\n}\n\nfunction _sanitize(data: string, jsDomWindow?: any): Buffer {\n  let domWindow;\n  try {\n    domWindow = window;\n  } catch {\n    // if js process run under nodejs require jsdom window\n    if (!jsDomWindow) {\n      throw Error('In node environment JSDOM window is required');\n    }\n    domWindow = jsDomWindow;\n  }\n  const DOMPurify = createDOMPurify(domWindow as any);\n  // purges malicious scripting from svg content\n  const cleanDOM = DOMPurify.sanitize(data);\n  return Buffer.from(cleanDOM);\n}\n\nexport interface ImageURIOpts {\n  metadata: any;\n  customGateway?: string;\n  jsdomWindow?: any;\n}\n\nexport function getImageURI({\n  metadata,\n  customGateway,\n  jsdomWindow,\n}: ImageURIOpts) {\n  // retrieves image uri from metadata, if image is onchain then convert to base64\n  const { image, image_url, image_data } = metadata;\n\n  const _image = image || image_url || image_data;\n  assert(_image, 'Image is not available');\n  const { uri: parsedURI } = resolveURI(_image || '', customGateway);\n\n  if (parsedURI.startsWith('data:') || parsedURI.startsWith('http')) {\n    return parsedURI;\n  }\n\n  if (isSVG(parsedURI)) {\n    // svg - image_data\n    const data = _sanitize(parsedURI, jsdomWindow);\n    return `data:image/svg+xml;base64,${data.toString('base64')}`;\n  }\n  return null;\n}\n\nexport function createCacheAdapter(fetch: Axios, ttl: number) {\n  // creates cache adapter for axios\n  const { setupCache } = require('axios-cache-interceptor');\n  setupCache(fetch, {\n    ttl: ttl * 1000,\n  });\n}\n\nfunction createFetcher({ ttl }: { ttl?: number }) {\n  const _fetch = axios.create();\n  if (ttl && ttl > 0) {\n    createCacheAdapter(_fetch, ttl);\n  }\n  return _fetch;\n}\n\nexport const fetch = createFetcher({});\n","import { BaseProvider } from '@ethersproject/providers';\nimport { Contract } from '@ethersproject/contracts';\nimport { Buffer } from 'buffer/';\nimport { fetch, resolveURI } from '../utils';\n\nconst abi = [\n  'function uri(uint256 _id) public view returns (string memory)',\n  'function balanceOf(address account, uint256 id) public view returns (uint256)',\n];\n\nexport default class ERC1155 {\n  async getMetadata(\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) {\n    // exclude opensea api which does not follow erc1155 spec\n    const tokenIDHex = !tokenID.startsWith('https://api.opensea.io')\n      ? tokenID.replace('0x', '').padStart(64, '0')\n      : tokenID;\n    const contract = new Contract(contractAddress, abi, provider);\n    const [tokenURI, balance] = await Promise.all([\n      contract.uri(tokenID),\n      ownerAddress && contract.balanceOf(ownerAddress, tokenID),\n    ]);\n    // if user has valid address and if token balance of given address is greater than 0\n    const isOwner = !!(ownerAddress && balance.gt(0));\n\n    const { uri: resolvedURI, isOnChain, isEncoded } = resolveURI(tokenURI);\n    let _resolvedUri = resolvedURI;\n    if (isOnChain) {\n      if (isEncoded) {\n        _resolvedUri = Buffer.from(\n          resolvedURI.replace('data:application/json;base64,', ''),\n          'base64'\n        ).toString();\n      }\n      return JSON.parse(_resolvedUri);\n    }\n    const response = await fetch(\n      resolvedURI.replace(/(?:0x)?{id}/, tokenIDHex)\n    );\n    const metadata = await response?.data;\n    return { ...metadata, is_owner: isOwner };\n  }\n}\n","import { BaseProvider } from '@ethersproject/providers';\nimport { Contract } from '@ethersproject/contracts';\nimport { Buffer } from 'buffer/';\nimport { fetch, resolveURI } from '../utils';\n\nconst abi = [\n  'function tokenURI(uint256 tokenId) external view returns (string memory)',\n  'function ownerOf(uint256 tokenId) public view returns (address)',\n];\n\nexport default class ERC721 {\n  async getMetadata(\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) {\n    const contract = new Contract(contractAddress, abi, provider);\n    const [tokenURI, owner] = await Promise.all([\n      contract.tokenURI(tokenID),\n      ownerAddress && contract.ownerOf(tokenID),\n    ]);\n    // if user has valid address and if owner of the nft matches with the owner address\n    const isOwner = !!(\n      ownerAddress && owner.toLowerCase() === ownerAddress.toLowerCase()\n    );\n\n    const { uri: resolvedURI, isOnChain, isEncoded } = resolveURI(tokenURI);\n    let _resolvedUri = resolvedURI;\n    if (isOnChain) {\n      if (isEncoded) {\n        _resolvedUri = Buffer.from(\n          resolvedURI.replace('data:application/json;base64,', ''),\n          'base64'\n        ).toString();\n      }\n      return JSON.parse(_resolvedUri);\n    }\n    const response = await fetch(resolvedURI.replace(/(?:0x)?{id}/, tokenID));\n    const metadata = await response?.data;\n    return { ...metadata, is_owner: isOwner };\n  }\n}\n","import { fetch, resolveURI } from '../utils';\n\nexport default class URI {\n  async getMetadata(uri: string) {\n    const { uri: resolvedURI, isOnChain } = resolveURI(uri);\n    if (isOnChain) {\n      return { image: resolvedURI };\n    }\n\n    // check if resolvedURI is an image, if it is return the url\n    const isImage = await isImageURI(resolvedURI);\n    if (isImage) {\n      return { image: resolvedURI };\n    }\n\n    // if resolvedURI is not an image, try retrieve the data.\n    const response = await fetch(resolvedURI);\n    return { image: response?.data };\n  }\n}\n\nfunction isImageURI(url: string) {\n  return new Promise((resolve) => {\n    fetch({ url, method: 'HEAD' })\n      .then((result) => {\n        if (result.status === 200) {\n          // retrieve content type header to check if content is image\n          const contentType = result.headers['content-type'];\n          resolve(contentType?.startsWith('image/'));\n        } else {\n          resolve(false);\n        }\n      })\n      .catch((error) => {\n        // if error is not cors related then fail\n        if (typeof error.response !== 'undefined') {\n          // in case of cors, use image api to validate if given url is an actual image\n          resolve(false);\n          return;\n        }\n        if (!globalThis.hasOwnProperty('Image')) {\n          // fail in NodeJS, since the error is not cors but any other network issue\n          resolve(false);\n          return;\n        }\n        const img = new Image();\n        img.onload = () => {\n          resolve(true);\n        };\n        img.onerror = () => {\n          resolve(false);\n        };\n        img.src = url;\n      });\n  });\n}\n","import { BaseProvider } from '@ethersproject/providers';\nimport ERC1155 from './specs/erc1155';\nimport ERC721 from './specs/erc721';\nimport { utils } from '@ensdomains/ens-avatar';\nimport URI from './specs/uri';\n\nexport async function handleSettled(promises: Promise<any>[]) {\n  const values = [];\n  const results = await Promise.allSettled(promises);\n  for (let result of results) {\n    if (result.status === 'fulfilled') values.push(result.value);\n    else if (result.status === 'rejected') values.push(null);\n  }\n  return values;\n}\n\nexport interface Spec {\n  getMetadata: (\n    provider: BaseProvider,\n    ownerAddress: string | undefined | null,\n    contractAddress: string,\n    tokenID: string\n  ) => Promise<any>;\n}\n\nexport const specs: { [key: string]: new () => Spec } = Object.freeze({\n  erc721: ERC721,\n  erc1155: ERC1155,\n});\n\nexport async function parseAvatarString(\n  walletAddress: string,\n  avatarURI: string,\n  provider: BaseProvider\n) {\n  // test case-insensitive in case of uppercase records\n  if (!/eip155:/i.test(avatarURI)) {\n    const uriSpec = new URI();\n    const metadata = await uriSpec.getMetadata(avatarURI);\n    return utils.getImageURI({ metadata });\n  }\n\n  // parse retrieved avatar uri\n  const { chainID, namespace, contractAddress, tokenID } =\n    utils.parseNFT(avatarURI);\n\n  // detect avatar spec by namespace\n  const Spec = specs[namespace];\n  if (!Spec) throw new Error(`Unsupported namespace: ${namespace}`);\n  const spec = new Spec();\n\n  // add meta information of the avatar record\n  const host_meta = {\n    chain_id: chainID,\n    namespace,\n    contract_address: contractAddress,\n    token_id: tokenID,\n    reference_url: `https://opensea.io/assets/${contractAddress}/${tokenID}`,\n  };\n\n  const metadata = await spec.getMetadata(\n    provider,\n    walletAddress,\n    contractAddress,\n    tokenID\n  );\n  const meta_ = { host_meta, ...metadata };\n  return utils.getImageURI({ metadata: meta_ });\n}\n","import { useContractRead } from 'wagmi';\nimport ENS from '@ensdomains/ens-contracts/artifacts/contracts/registry/ENS.sol/ENS.json';\n\nexport function useEnsContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: ENS.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useEnsContractRead;\n","import { useContractWrite } from 'wagmi';\nimport ENS from '@ensdomains/ens-contracts/artifacts/contracts/registry/ENS.sol/ENS.json';\n\nexport function useEnsContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: ENS.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useEnsContractWrite;\n","import { useContract } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverContract(address: string): any {\n  return useContract({\n    addressOrName: address,\n    contractInterface: PublicResolver.abi,\n  });\n}\n\nexport default usePublicResolverContract;\n","import { useContractRead } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: PublicResolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default usePublicResolverRead;\n","import { useContractWrite } from 'wagmi';\nimport PublicResolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';\n\nexport function usePublicResolverWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: PublicResolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default usePublicResolverWrite;\n","import { useContract } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContract(address: string): any {\n  return useContract({\n    addressOrName: address,\n    contractInterface: Resolver.abi,\n  });\n}\n\nexport default useResolverContract;\n","import { useContractRead } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: Resolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useResolverContractRead;\n","import { useContractWrite } from 'wagmi';\nimport Resolver from '@ensdomains/ens-contracts/artifacts/contracts/resolvers/Resolver.sol/Resolver.json';\n\nexport function useResolverContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: Resolver.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useResolverContractWrite;\n","import { useContractRead } from 'wagmi';\nimport ReverseRegistrar from '@ensdomains/ens-contracts/artifacts/contracts/registry/ReverseRegistrar.sol/ReverseRegistrar.json';\n\nexport function useReverseRegistrarContractRead(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractRead(\n    {\n      addressOrName: address,\n      contractInterface: ReverseRegistrar.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useReverseRegistrarContractRead;\n","import { useContractWrite } from 'wagmi';\nimport ReverseRegistrar from '@ensdomains/ens-contracts/artifacts/contracts/registry/ReverseRegistrar.sol/ReverseRegistrar.json';\n\nexport function useReverseRegistrarContractWrite(\n  address: string,\n  method: string,\n  args: any[]\n): any {\n  return useContractWrite(\n    {\n      addressOrName: address,\n      contractInterface: ReverseRegistrar.abi,\n    },\n    method,\n    {\n      args: args,\n    }\n  );\n}\n\nexport default useReverseRegistrarContractWrite;\n"],"names":["ipfsRegex","protocol","root","subpath","target","subtarget","base64Regex","dataURIRegex","resolveURI","uri","customGateway","isEncoded","test","startsWith","isOnChain","ipfsGateway","ipfsRegexpResult","match","groups","hash","Boolean","multiformats","parse","asCID","_error","isCID","urlJoin","replace","createFetcher","ttl","_fetch","axios","create","fetch","setupCache","require","createCacheAdapter","abi","ERC1155","getMetadata","provider","ownerAddress","contractAddress","tokenID","tokenIDHex","padStart","contract","Contract","_context","Promise","all","balanceOf","tokenURI","_yield$Promise$all","balance","isOwner","gt","_resolveURI","_resolvedUri","resolvedURI","Buffer","from","toString","JSON","response","data","is_owner","ERC721","ownerOf","owner","toLowerCase","URI","image","isImageURI","url","resolve","method","then","result","status","contentType","headers","error","globalThis","hasOwnProperty","img","Image","onload","onerror","src","specs","Object","freeze","erc721","erc1155","walletAddress","avatarURI","_context2","uriSpec","utils","getImageURI","metadata","_utils$parseNFT","parseNFT","chainID","Spec","namespace","Error","spec","host_meta","chain_id","contract_address","token_id","reference_url","meta_","address","args","useContractRead","addressOrName","contractInterface","ENS","useContractWrite","useContract","PublicResolver","Resolver","ReverseRegistrar"],"mappings":"i2RAOA,IAEMA,IACJ,4DADaC,WAAAC,OAAAC,UAAAC,SAAAC,cAETC,EAAc,wCACdC,EAAe,sDAmELC,EACdC,EACAC,GAGA,IAAMC,EAAYL,EAAYM,KAAKH,GACnC,GAAIE,GAAaF,EAAII,WAAW,QAC9B,MAAO,CAAEJ,IAAAA,EAAKK,UAAWH,EAAWA,UAAAA,GAGtC,IAAMI,EAAcL,GAAiB,kBAC/BM,EAAmBP,EAAIQ,MAAMjB,YAM/BgB,SAAAA,EAAkBE,SAAU,GAF9Bd,IAAAA,WACAC,UAAAA,aAAY,KAEd,MAAkB,aALhBJ,UAKwC,YAJxCE,UAIoDC,WAnFlCe,GAEpB,IACE,MAAoB,iBAATA,EACFC,QAAQC,MAAiBC,MAAMH,IAGjCC,QAAQC,MAAiBE,MAAMJ,IACtC,MAAOK,GACP,OAAO,GAgFEC,CAAMrB,GAER,CACLK,IAAKiB,UAAQX,EAnGE,SAmGyBX,EAAQC,GAChDS,WAAW,EACXH,WAAW,GAIN,CACLF,IAAKA,EAAIkB,QAAQpB,EAAc,IAC/BO,WAAW,EACXH,WAAW,GAjBN,CACLF,IAAKiB,UAAQX,EA3FE,SA2FyBX,EAAQC,GAChDS,WAAW,EACXH,WAAW,GA0EjB,SAASiB,SAAgBC,IAAAA,IACjBC,EAASC,EAAMC,SAIrB,OAHIH,GAAOA,EAAM,YAVgBI,EAAcJ,IAG/CK,EADuBC,QAAQ,2BAAvBD,YACGD,EAAO,CAChBJ,IAAW,IAANA,IAOLO,CAAmBN,EAAQD,GAEtBC,EAGF,IAAMG,EAAQL,EAAc,IClL7BS,EAAM,CACV,gEACA,iFAGmBC,8CACbC,yCAAN,WACEC,EACAC,EACAC,EACAC,GAJF,0BAAA,6BAAA,OAAA,sBAAA,OAAA,OAOQC,EAAcD,EAAQ9B,WAAW,0BAEnC8B,EADAA,EAAQhB,QAAQ,KAAM,IAAIkB,SAAS,GAAI,KAErCC,EAAW,IAAIC,WAASL,EAAiBL,EAAKG,GAVtDQ,SAWoCC,QAAQC,IAAI,CAC5CJ,EAASrC,IAAIkC,GACbF,GAAgBK,EAASK,UAAUV,EAAcE,KAbrD,OAAA,GAWSS,GAXTC,aAWmBC,OAKXC,KAAad,IAAgBa,EAAQE,GAAG,IAhBhDC,EAkBqDjD,EAAW4C,GAAzBzC,IAAAA,UACjC+C,EADSC,IAALlD,OAAkBK,WAlB5BkC,UAAA,MAAA,OAqBQrC,IACF+C,EAAeE,SAAOC,KACpBF,EAAYhC,QAAQ,gCAAiC,IACrD,UACAmC,8BAEGC,KAAKzC,MAAMoC,IA3BtB,QAAA,OAAAV,UA6ByBf,EACrB0B,EAAYhC,QAAQ,cAAeiB,IA9BvC,QAAA,OA6BQoB,SA7BRhB,gBAgCyBgB,SAAAA,EAAUC,KAhCnC,QAAA,sCAiCwBC,SAAUX,KAjClC,QAAA,UAAA,2FCNIlB,EAAM,CACV,2EACA,mEAGmB8B,8CACb5B,yCAAN,WACEC,EACAC,EACAC,EACAC,GAJF,wBAAA,6BAAA,OAAA,sBAAA,OAAA,OAMQG,EAAW,IAAIC,WAASL,EAAiBL,EAAKG,GANtDQ,SAOkCC,QAAQC,IAAI,CAC1CJ,EAASM,SAAST,GAClBF,GAAgBK,EAASsB,QAAQzB,KATrC,OAAA,GAOSS,GAPTC,aAOmBgB,OAKXd,KACJd,GAAgB4B,EAAMC,gBAAkB7B,EAAa6B,eAbzDb,EAgBqDjD,EAAW4C,GAAzBzC,IAAAA,UACjC+C,EADSC,IAALlD,OAAkBK,WAhB5BkC,UAAA,MAAA,OAmBQrC,IACF+C,EAAeE,SAAOC,KACpBF,EAAYhC,QAAQ,gCAAiC,IACrD,UACAmC,8BAEGC,KAAKzC,MAAMoC,IAzBtB,QAAA,OAAAV,UA2ByBf,EAAM0B,EAAYhC,QAAQ,cAAegB,IA3BlE,QAAA,OA2BQqB,SA3BRhB,gBA4ByBgB,SAAAA,EAAUC,KA5BnC,QAAA,sCA6BwBC,SAAUX,KA7BlC,QAAA,UAAA,2FCTmBgB,8CACbhC,yCAAN,WAAkB9B,GAAlB,UAAA,6BAAA,OAAA,sBAAA,OAAA,GAAAgD,EAC0CjD,EAAWC,GAAtCkD,IAALlD,OAAkBK,WAD5BkC,SAAA,MAAA,yBAGW,CAAEwB,MAAOb,IAHpB,OAAA,OAAAX,SAOwByB,EAAWd,GAPnC,OAAA,YAAAX,SAAA,MAAA,yBASW,CAAEwB,MAAOb,IATpB,OAAA,OAAAX,UAayBf,EAAM0B,GAb/B,QAAA,yBAcS,CAAEa,aADHR,iBACUA,EAAUC,OAd5B,QAAA,UAAA,qFAkBF,SAASQ,EAAWC,GAClB,OAAO,IAAIzB,SAAQ,SAAC0B,GAClB1C,EAAM,CAAEyC,IAAAA,EAAKE,OAAQ,SAClBC,MAAK,SAACC,GACL,GAAsB,MAAlBA,EAAOC,OAAgB,CAEzB,IAAMC,EAAcF,EAAOG,QAAQ,gBACnCN,QAAQK,SAAAA,EAAanE,WAAW,gBAEhC8D,GAAQ,aAGL,SAACO,GAEN,QAA8B,IAAnBA,EAAMlB,SAKjB,GAAKmB,WAAWC,eAAe,SAA/B,CAKA,IAAMC,EAAM,IAAIC,MAChBD,EAAIE,OAAS,WACXZ,GAAQ,IAEVU,EAAIG,QAAU,WACZb,GAAQ,IAEVU,EAAII,IAAMf,OAVRC,GAAQ,QALRA,GAAQ,SCZX,IAAMe,EAA2CC,OAAOC,OAAO,CACpEC,OAAQ1B,EACR2B,QAASxD,sCAGJ,WACLyD,EACAC,EACAxD,GAHK,wBAAA,6BAAA,OAAA,sBAAA,OAAA,GAMA,WAAW5B,KAAKoF,IANhBC,SAAA,MAAA,OAOGC,EAAU,IAAI3B,EAPjB0B,SAQoBC,EAAQ3D,YAAYyD,GARxC,OAAA,yBASIG,QAAMC,YAAY,CAAEC,mBATxB,OAAA,GAAAC,EAcHH,QAAMI,SAASP,GADTQ,IAAAA,QAAoB9D,IAAAA,gBAAiBC,IAAAA,QAIvC8D,EAAOf,EAJIgB,IAAAA,YAbZT,UAAA,MAAA,MAkBY,IAAIU,gCAAgCD,GAlBhD,QAAA,OAmBCE,EAAO,IAAIH,EAGXI,EAAY,CAChBC,SAAUN,EACVE,UAAAA,EACAK,iBAAkBrE,EAClBsE,SAAUrE,EACVsE,2CAA4CvE,MAAmBC,GA3B5DsD,UA8BkBW,EAAKrE,YAC1BC,EACAuD,EACArD,EACAC,GAlCG,QAAA,OAoCCuE,KAAUL,UAAAA,6BACTV,QAAMC,YAAY,CAAEC,SAAUa,KArChC,QAAA,UAAA,8FAAP,gBAAA,oEC1BEC,EACAvC,EACAwC,GAEA,OAAOC,kBACL,CACEC,cAAeH,EACfI,kBAAmBC,EAAInF,KAEzBuC,EACA,CACEwC,KAAMA,0CCXVD,EACAvC,EACAwC,GAEA,OAAOK,mBACL,CACEH,cAAeH,EACfI,kBAAmBC,EAAInF,KAEzBuC,EACA,CACEwC,KAAMA,gDCZ8BD,GACxC,OAAOO,cAAY,CACjBJ,cAAeH,EACfI,kBAAmBI,EAAetF,8CCFpC8E,EACAvC,EACAwC,GAEA,OAAOC,kBACL,CACEC,cAAeH,EACfI,kBAAmBI,EAAetF,KAEpCuC,EACA,CACEwC,KAAMA,6CCXVD,EACAvC,EACAwC,GAEA,OAAOK,mBACL,CACEH,cAAeH,EACfI,kBAAmBI,EAAetF,KAEpCuC,EACA,CACEwC,KAAMA,0CCZwBD,GAClC,OAAOO,cAAY,CACjBJ,cAAeH,EACfI,kBAAmBK,EAASvF,gDCF9B8E,EACAvC,EACAwC,GAEA,OAAOC,kBACL,CACEC,cAAeH,EACfI,kBAAmBK,EAASvF,KAE9BuC,EACA,CACEwC,KAAMA,+CCXVD,EACAvC,EACAwC,GAEA,OAAOK,mBACL,CACEH,cAAeH,EACfI,kBAAmBK,EAASvF,KAE9BuC,EACA,CACEwC,KAAMA,sDCXVD,EACAvC,EACAwC,GAEA,OAAOC,kBACL,CACEC,cAAeH,EACfI,kBAAmBM,EAAiBxF,KAEtCuC,EACA,CACEwC,KAAMA,uDCXVD,EACAvC,EACAwC,GAEA,OAAOK,mBACL,CACEH,cAAeH,EACfI,kBAAmBM,EAAiBxF,KAEtCuC,EACA,CACEwC,KAAMA"}