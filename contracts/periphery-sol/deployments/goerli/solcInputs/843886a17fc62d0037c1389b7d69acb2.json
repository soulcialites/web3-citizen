{
  "language": "Solidity",
  "sources": {
    "contracts/TrustResolver3.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\ninterface IDeployer {\n    function getNations() external view returns (address[] memory);\n\n    function getNationCount() external view returns (uint256);\n\n    function deployNation(string memory name, string memory symbol, address citizenAlpha, address[] memory founders) external returns (address);\n\n} \n\ninterface INation {\n    function getCitizenAlpha() external view returns (address);\n\n    function hasRole(bytes32 role, address citizen) external view returns(bool);\n\n    function metadata() external view returns(string memory, string memory, string memory);\n\n    function roleStatus(bytes32 role) external view returns(bool);\n\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n}\n\ninterface ICitizenAlpha1 {\n    function ownerOf(uint256 _id) external view returns (address owner);\n\n    function issue(address _citizen) external;\n\n    function revoke(address _citizen) external;\n\n    function getId(address citizen) external view returns (uint256);\n\n    function getLink(address citizen) external view returns (address issuer);\n\n    function hasRole(bytes32 role, address citizen) external view returns (bool);\n\n    function isCitizen(address citizen) external view returns (bool status);\n\n    function totalIssued() external view returns(uint256);\n\n    function getMetadata() external view returns(address);\n}\n\n\ncontract TrustResolver3 {\n\n    address private immutable _deployer;\n\n    struct NationRole {\n        address nation;\n        bytes32 role;\n    }\n\n    struct NationRoleMemberCount {\n        bytes32 role;\n        uint roleMemberCount;\n    }\n\n    struct NationDetails {\n        string name;\n        string symbol;\n        string did;\n        uint256 population;\n        bytes32[] nationRoles;\n        NationRoleMemberCount[] nationRoleMemberCount;\n    }\n\n    constructor(address _deployer_) {\n        _deployer = _deployer_;\n    }\n\n    modifier _onlyValidNations(address _nation) {\n        address[] memory nations = IDeployer(_deployer).getNations();\n        uint count = nations.length;\n        bool validNation = false;\n        for (uint i = 0; i < count; i++){\n            if (nations[i] == _nation) {\n                validNation = true;\n                break;\n            }\n        }\n        require(validNation, \"TrustResolver: nation does not exist\");\n        _;\n    }\n\n    function createNation(string memory name, string memory symbol, address[] memory founders) external returns (address) {\n        address[] memory nations = IDeployer(_deployer).getNations();\n        require(nations.length > 0, \"First democracy should not be set from TrustResolver\");\n        address _citizenAlpha = INation(nations[0]).getCitizenAlpha();\n        return IDeployer(_deployer).deployNation(name, symbol, _citizenAlpha, founders);\n    }\n\n    function getNationDetails(address _nation, bytes32[] memory _allRoles) public view _onlyValidNations(_nation) returns(NationDetails memory) {\n        (string memory _name, string memory _symbol, string memory _did) = INation(_nation).metadata();\n        address _citizenAlpha = INation(_nation).getCitizenAlpha();\n        uint256 _population = ICitizenAlpha1(_citizenAlpha).totalIssued();\n        bytes32[] memory _nationRoles = _getNationActiveRoles(_nation, _allRoles);\n        NationRoleMemberCount[] memory _nationRolesMembersCount = getNationRolesMembersCount(_nation, _nationRoles);\n        NationDetails memory nationDetails = NationDetails({name: _name, symbol: _symbol, did: _did, \n                        population: _population, nationRoles: _nationRoles, nationRoleMemberCount: _nationRolesMembersCount});\n        return nationDetails;\n    }\n\n    function getNationRolesMembersCount(address _nation, bytes32[] memory _roles_) public view _onlyValidNations(_nation) returns(NationRoleMemberCount[] memory) {\n        uint256 count = _roles_.length;\n        NationRoleMemberCount[] memory result = new NationRoleMemberCount[](count);\n        for (uint256 i=0; i<count; i++){\n            bytes32 currentRole = _roles_[i];\n            uint256 currentRoleMemberCount = INation(_nation).getRoleMemberCount(currentRole);\n            NationRoleMemberCount memory temp = NationRoleMemberCount({role: currentRole, roleMemberCount: currentRoleMemberCount});\n            result[i] = temp;\n        }\n        return result;\n    } \n\n    function _getNationActiveRoles(address _nation, bytes32[] memory _allRoles) private view returns(bytes32[] memory) {\n        uint allRolesCount = _allRoles.length;\n        bytes32[] memory nationActiveRolesTemp = new bytes32[](allRolesCount);\n        uint nationRolesCount = 0;\n        for (uint256 i=0; i < allRolesCount; i++) {\n            bytes32 currentRole = _allRoles[i];\n            if (INation(_nation).roleStatus(currentRole)) {\n                nationActiveRolesTemp[nationRolesCount] = currentRole;\n                nationRolesCount++;\n            }\n        }\n        if (nationRolesCount == 0) {\n            return new bytes32[](0);\n        }\n        else {\n            bytes32[] memory nationRoles = new bytes32[](nationRolesCount);\n            for (uint256 i=0; i < nationRolesCount; i++) {\n                nationRoles[i] = nationActiveRolesTemp[i];\n            }\n            return nationRoles;\n        }\n    } \n\n    function _getCitizenNationRoles(address citizen, address nation, bytes32[] memory _allRoles) private view returns(bytes32[] memory) {\n        uint rolesCount = _allRoles.length;\n        bytes32[] memory citizenRolesTemp = new bytes32[](rolesCount);\n        uint256 citizenRolesCount = 0;\n        for (uint256 i=0; i < rolesCount; i++) {\n            bytes32 currentRole = _allRoles[i];\n            if (INation(nation).hasRole(currentRole, citizen)) {\n                citizenRolesTemp[citizenRolesCount] = currentRole;\n                citizenRolesCount++;\n            }\n        }\n        if (citizenRolesCount == 0) {\n            return new bytes32[](0);\n        }\n        else {\n            bytes32[] memory citizenRoles = new bytes32[](citizenRolesCount);\n            for (uint256 i=0; i < citizenRolesCount; i++) {\n                citizenRoles[i] = citizenRolesTemp[i];\n            }\n            return citizenRoles;\n        }\n    }\n\n    function getCitizenNationRoles(address citizen, address nation, bytes32[] memory _allRoles) public view _onlyValidNations(nation) returns(bytes32[] memory) {\n        return _getCitizenNationRoles(citizen, nation, _allRoles);\n    }\n\n    function getCitizenNationsRoles(address citizen, bytes32[] memory _allRoles) public view returns(NationRole[] memory) {\n        uint nationsCount = IDeployer(_deployer).getNationCount();\n        address[] memory nations = IDeployer(_deployer).getNations();\n        uint rolesCount = _allRoles.length;\n        NationRole[] memory resultsTemp = new NationRole[](nationsCount * rolesCount);\n        uint256 count = 0;\n        for (uint256 i = 0; i < nationsCount; i++) {\n            address nationAddress = nations[i];\n            bytes32[] memory citizenNationRolesTemp = _getCitizenNationRoles(citizen, nationAddress, _allRoles);\n            for (uint256 j = 0; j < citizenNationRolesTemp.length; j++) {\n                resultsTemp[count] = NationRole({nation: nationAddress, role: citizenNationRolesTemp[j]});\n                count++;\n            } \n        }\n        if (count == 0) {\n            return new NationRole[](0);\n        }\n        else {\n            NationRole[] memory citizenNationsRoles = new NationRole[](count);\n            for (uint i = 0; i < count; i ++) {\n                citizenNationsRoles[i] = resultsTemp[i];\n            }\n            return citizenNationsRoles;\n        }\n    }\n\n    function getDeployer() public view returns(address) {\n        return _deployer;\n    }\n\n    function getCitizenNations(address citizen) public view returns(address[] memory) {\n        uint count = IDeployer(_deployer).getNationCount();\n        address[] memory citizenNationsTemp = new address[](count);\n        address[] memory nations = IDeployer(_deployer).getNations();\n        uint citizenNationsCount = 0;\n        for (uint i = 0; i < count; i++) {\n            address nationAddress = nations[i];\n            if (isCitizenNation(citizen, nationAddress)) {\n                citizenNationsTemp[citizenNationsCount] = nationAddress;\n                citizenNationsCount++;\n            }\n        }\n        if (citizenNationsCount == 0) {\n            return new address[](0);\n        }\n        else {\n            address[] memory citizenNations = new address[](citizenNationsCount);\n            for (uint i = 0; i < citizenNationsCount; i++) {\n                citizenNations[i] = citizenNationsTemp[i];\n            }\n            return citizenNations;\n        }\n\n    }\n\n    function isCitizenNation(address citizen_, address nation_) public view returns(bool) {\n        address citizenAlpha = INation(nation_).getCitizenAlpha();\n        return ICitizenAlpha1(citizenAlpha).isCitizen(citizen_);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}